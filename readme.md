### изменения

#### `src/UserImitation.php`
+ добавлено использование зависимости через конструктор,
```php
    public function __construct(
        string $whoRoleOrName,
        CreatorServiceInterface $creatorService = new CreatorService()
    ) {
        $this->creator = $creatorService;
        $roleOrName = StringClass::build()->from($whoRoleOrName);
        $this->creator->setRoleOrName($roleOrName);
    }
```
* вместо вызова фабрики внутри конструктора
```php
    public function __construct(string $whoRoleOrName) {
        $this->creator = FactoryCreatorService::create();
        $this->creator->setRoleOrName(StringClass::build()->from($whoRoleOrName));
    }
```
Считаю этот пример не завершенным, т.к. создание класса выполнено, как значение по-умолчанию для параметра,
такая 'магия' позволила сохранить выполнение тестов без их изменения, что считаю аргументом в пользу того,
что рефакторинг выполнен корректно.


#### `src/PathHomeSource.php`
* данный класс выполняет ответственность только получение абсолютного пути к директории с исходниками,
для формирования корректного пути к бд sqlite. Тут применяются принцип SOLID - единый ответственности.


#### `src/interface/CreatorServiceInterface.php`
* данный интерфейс описывает доступные методы, используемые основным экземпляром программы поведение.
Использование интерфейса описано одним из SOLID принципом, о том что поведение задается интерфейсом,
реализация поведения программируется позже, сохраняя описанные шаги интерфейса, 
т.к. поведение зависит от интерфейса, а не интерфейс от реализации поведения.

#### `src/factory/CreatorService.php`
* фабричный класс. Создает нужные сервисы для получения результата соответствующих вызываемому методу.
Тут применил SOLID - класс ответственен за создание сервисов (единая ответственность из SOLID),
при этом изменения функционала сервисов при необходимости выполняется внутри создаваемых сервисов
(принцип открытости-замкнутости SOLID), то есть при изменении логики обработки изменения будут вне этого класса. 

#### `src/interface/FetchableArrayInterface.php`
* интерфейс для получения данных (списка соответствия класса и типа пользователя) для последующего сопоставления.
Данный список может быть статичным и браться из источника данных (БД, массив) или быть динамичным - например,
данные читаются построчно из файла, или поочередно "читаются" из http-запроса.
Интерфейс обеспечивает уникальную структуру массив, причем с сокрытием внутренней структуры хранения.
применяются SOLID принципы
- единая ответственность получения данных, не зависимо от типа источника.
- открытость\закрытость к расширению - для доступа используется только один метод и есть требование к типу результата.
- есть зависимость только от интерфейса, реализация ни как не регламентируется (важен результирующий тип array).
Считаю такой универсальный интерфейс получения данных, позволит использовать лишних публичных методов,
- что способствует соблюдению YAGNI, но в то же время "не связывает руки" для нарушения этой идеи.
- если при реализации интерфейса помнить о KISS, то можно получить минимальный рабочий функционал. И двигаться по следующим задачам.
- про соблюдение DRY - дискуссионный момент: метод интерфейса будет повторяться в каждой реализации,
возможно так же частично повторится часть функционала, но это уже о будущем функционале, его проектировании и реализации.  
Мое мнение, что повторение метода и сигнатуры метода - это не то "повторение", которое рекомендуется `don't repeat`.

-- --
#### `tests/IntegrationSystem/UserImitation_full_Test.php`
Общая идея сервиса:
- сервис получает имя пользователя (или гостя - если пользователь не известен)
- приветствует "особым" образом.

примеры
```
Админ (admin) - 'Hello, admin!'
без_имени - 'Hello, guest!'
Галий Юрий Цезарь (Gaius Iulius Caesar) - 'Ave, Csr'
```
Русификация (или другая национализация вывода/ввода) в данной версии не реализована.
